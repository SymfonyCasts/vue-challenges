extending_instancedynamicdata:
  question: |
    Suppose we have a Vue component that looks like this:

    ```javascript
    const app = new Vue({
        el: '#app',
        template: '<span class="title">{{ title }}</span>
    });
    ```

    and you want to add `title` as a new "data" key to this component.
    How could we do that *and* set its initial value to `Vue challenge!`.
    How would you go about initializing this data?
  explanation: |
    That's right! `data` is a function that returns an object. The properties
    in this object will be accessible from the template! The function shorthand
    syntax - `data() {}` instead of `data: function() {}` - allows us to make our
    component more readable.
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          data: `title='Vue challenge!'`,
          ```
        b: |
          ```javascript
          data() { return { title: 'Vue challenge!' }; },
          ```
        c: |
          ```javascript
          data() { title = 'Vue challenge!'; },
          ```
        d: |
          ```javascript
          data: 'Vue challenge!',
          ```
      correct: b

extending_singlefilecomponent:
  question: |
    Imagine you want to build a `.vue` single file component that renders a
    page header. It needs to have a `title` data key that it uses to render the
    template.

    Which one of these code snippets would accomplish this?
  explanation: |
    Correct! A vue single file component has at least 2 elements: a `<template>`
    tag that holds the template and a `<script>` tag that `export default`
    one object with the rest of the options.
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <h1>{{ title }}</h1>

          <script>
          const component = {
              name: 'TitleComponent',
              data: {
                  title: '',
              },
          };
          </script>
          ```
        b: |
          ```vue
          <template>
              <h1>{{ title }}</h1>
          </template>

          <script>
          const name = 'TitleComponent';
          const data = {
              title: ''
          };
          </script>
          ```
        c: |
          ```vue
          <template>
              <h1>{{ title }}</h1>
          </template>

          <script>
          const name = 'TitleComponent';
          const data = function() {
              return {
                  title: ''
              };
          };
          </script>
          ```
        d: |
          ```vue
          <template>
              <h1>{{ title }}</h1>
          </template>

          <script>
          export default {
              name: 'TitleComponent',
              data() {
                  return { title: '' };
              },
          };
          </script>
          ```
      correct: d

extending_dataandvuedevtools:
  question: |
    Which of these is NOT valid syntax to initialize a data object
    in Vue?
  explanation: |
    That's right! Data can be just an `Object`, or (more commonly) a function
    that *returns* an `Object`! Option "b" is proper syntax but doesn't return
    anything!
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          data: {
              legend: "My Legend Goes Here!",
          },
          ```
        b: |
          ```javascript
          data: function() {
              const legend = "My Legend Goes Here!;
          },
        c: |
          ```javascript
          data(): {
              return {
                legend: "My Legend Goes Here!",
              };
          },
          ```
        d: |
          ```javascript
          data: () => ({
              legend: "My Legend Goes Here!",
          }),
          ```
      correct: b

extending_childcomponent:
  question: |
    Which of these is NOT a reason to consider breaking a component
    into smaller sub-components?
  explanation: |
    Correct! Splitting a component into smaller components can help you reuse code,
    isolate complex logic, or make your templates smaller and more readable. But
    this has no (significant) effect on the final size of your JavaScript code.
  features:
    multiple_choice:
      choices:
        a: Part of the component has a special functionality/logic.
        b: Part of the component needs to be reused in other parts of the application.
        c: Extracting part of the component will make its footprint smaller.
        d: Extracting part of a template into a sub-component will make it easier to read and understand.
      correct: c

extending_childcomponent2:
  question: |
    Suppose we have an empty component that looks like this:

    ```vue
    <template>
        <div></div>
    </template>

    <script>
    export default {
        name: 'MainComponent',
    };
    </script>
    ```

    We now want to import a child component (that lives at `@/components/title-component`)
    and render it inside `MainComponent`. What code would accomplish this?
  explanation: |
    Correct! First, you need to import the file that holds the Vue component
    (like normal JavaScript). Next, the `components` option is an *object* containing
    all of the components that you want to make *available* in the template. Once
    you've made it available, you can *use* it in the template!

    Fun fact: the reason `components` is an object is that you are *really* setting
    a key-value pair of components to make available. For example:

    ```
    export default {
        // ...
        components: {
            // this is short for TitleComponent: TitleComponent
            TitleComponent,

            // you won't do this, but it's legal to set any key to a component
            // this would allow us to use <foo /> in the template to render the title
            foo: TitleComponent
        },
    };
    ```
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <div></div>
          </template>

          <script>
          import TitleComponent from '@/components/title-component';

          export default {
              name: 'MainComponent',
              components: {
                  TitleComponent,
              },
          };
          </script>
          ```
        b: |
          ```vue
          <template>
              <div><title-component /></div>
          </template>

          <script>
          import TitleComponent from '@/components/title-component';

          export default {
              name: 'MainComponent',
              components: {
                  TitleComponent,
              },
          };
          </script>
          ```
        c: |
          ```vue
          <template>
              <div><title-component /></div>
          </template>

          <script>
          import TitleComponent from '@/components/title-component';

          export default {
              name: 'MainComponent',
              components: [
                  TitleComponent,
              ],
          };
          </script>
          ```
        d: |
          ```vue
          <template>
              <div><title-component /></div>
          </template>

          <script>
          export default {
              name: 'MainComponent',
              components: {
                  TitleComponent,
              },
          };
          </script>
          ```
      correct: b

extnding_passinginfotochild:
  question: |
    Suppose we have a shiny Title component that looks like this:

    ```vue
    <template>
        <div>{{ title }}</div>
    </template>

    <script>
    export default {
        name: 'TitleComponent',
    };
    </script>
    ```

    We want other components to be able to pass a `title` to this component as a prop.
    Which option would NOT be a valid way to define the `title` prop?
  explanation: |
    Correct! To define `props` for our component, we need to declare the
    component `props` property. Its simplest form is an array
    of strings, where each string is a prop name!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          export default {
              name: 'TitleComponent',
              props: ['title'],
          };
          ```
        b: |
          ```vue
          export default {
              name: 'TitleComponent',
              props: {
                  title: String,
              },
          };
          ```
        c: |
          ```vue
          export default {
              name: 'TitleComponent',
              props: {
                  title: {
                      type: String,
                  },
              },
          };
          ```
        d: |
          ```vue
          export default {
              name: 'TitleComponent',
              props: { 'title' : true },
          };
          ```
      correct: d

extnding_passinginfotochild2:
  question: |
    Ok! We now have a TitleComponent with a `title` prop:

    ```vue
    <template>
        <div>{{ title }}</div>
    </template>

    <script>
    export default {
        name: 'TitleComponent',
        props: ['title'],
    };
    </script>
    ```

    Imagine that we want to pass the string `Discount Broken Furniture` to it
    from a parent component. What's the correct way to do this?
  explanation: |
    That's right! Props behave exactly like HTML attributes in Vue! The easiest
    way to pass down a prop is to just declare it staticaly as an attribute.
    In our next lesson, we explore the other way of passing a prop: Using the
    `v-bind` directive, which allows us to use JavaScript for dynamic prop values!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <title-component prop:title="Discount Broken Furniture"
          </template>
          ```
        b: |
          ```vue
          <template>
              <title-component title="Discount Broken Furniture"
          </template>
          ```
        c: |
          ```vue
          <template>
              <title-component title="'Discount Broken Furniture'"
          </template>
          ```
        d: |
          ```vue
          <template>
              <title-component :title="Discount Broken Furniture"
          </template>
          ```
      correct: b

extending_dynamicattributes:
  question: |
    Suppose we have this component imported and ready to use in our template:

    ```vue
    <template>
        <div>{{ title }}</div>
    </template>

    <script>
    export default {
        name: 'TitleComponent',
        props: ['title'],
    };
    </script>
    ```

    And we want to pass in the `title` prop with the value of an imaginary data
    key called `categoryName`. What would the correct way of doing it in the
    template be using a shortcut syntax?
  explanation: |
    Correct! When using the shortcut syntax - equivalent to `v-bind:title` - we're
    converting the attribute value into a JavaScript expression where we can
    access all our object's props and data members directly. So doing
    `:title="ourTitle"` will work just fine!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <title-component :title="categoryName" />
          </template>
          ```
        b: |
          ```vue
          <template>
              <title-component title="{{ categoryName }}" />
          </template>
          ```
        c: |
          ```vue
          <template>
              <title-component :title="{{ categoryName }}" />
          </template>
          ```
        d: |
          ```vue
          <template>
              <title-component :title="'categoryName'" />
          </template>
          ```
      correct: a

extending_dynamicattributes2:
  question: |
    Say we have a component with a prop `title` defined using the simple
    syntax:

    ```javascript
    props: [title],
    ```

    But now, we'd like Vue to be able to do some validation for us when
    the component is rendered: we want `title` to accept a String and to
    be required. How can we do this?
  explanation: |
    Correct! We NEED to pass an object whose members are equal to the names
    of our defined props. Each member is  itself another object with the
    options `type` - which can be equal to a JavaScript type object, like
    `String` - and `required` which is a boolean.

    > When `required` is `false`, you can also define a `default` value using
    > that option.

    > Types are defined using JavaScript type classes, not its instantiated
    > objects. That's why `String` works but `String()`, `'String'`, `''`, or
    > `new String()` will fail!
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          props: {
              title: {
                  type: String,
                  required,
              },
          },
          ```
        b: |
          ```javascript
          props: {
              title: [String, true],
          },
          ```
        c: |
          ```javascript
          props: {
              title: {
                  type: String,
                  required: true,
              },
          },
          ```
        d: |
          ```javascript
          props: {
              title: {
                  type: new String(),
                  required: true,
              },
          },
          ```
      correct: c

extending_modularcss:
  question: |
    What is the *minimum* code you need in a `<style>` tag (inside a `.vue`
    single file component) to make it modular?
  explanation: |
    That's right, the only thing you need to add to it in order to make it
    modular is the `module` attribute! While a similar and valid option
    would be `scoped` attribute, this doesn't exactly compute into a "modular"
    style system using webpack.
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <style module>
          </style>
          ```
        b: |
          ```vue
          <style lang="scss" module>
          </style>
          ```
        c: |
          ```vue
          <style type="module">
          </style>
          ```
        d: |
          ```vue
          <style scoped>
          </style>
          ```
      correct: a

extending_modularcss2:
  question: |
    Imagine we have a component with the following modular css:

    ```vue
    <style module>
    .component {
        background-color: red;
    }
    </style>
    ```

    What do we need to do in the template to grab this style class from
    inside our component template?
  explanation: |
    You did it!

    In order to access modular css, we *need* to use the `$style` variable using a v-bind
    directive! Style is actually an object with a property for every class defined
    in `<style>`.

    Each property is mapped to whatever that class ends up being in the final
    code!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          class="$style.component"
          ```
        b: |
          ```vue
          :class="style.component"
          ```
        c: |
          ```vue
          class="style.component"
          ```
        d: |
          ```vue
          :class="$style.component"
          ```
      correct: d

extending_aliases:
  question: |
    Suppose we have a Vue application living inside our Symfony project and
    its components are located at `/assets/js/vue`. To follow Vue standards,
    we want to be able to access this directory by just typing `@/...` in
    our import statements.

    How can we do this?
  explanation: |
    Correct! `.addAliases()` is a *function* that accepts an object where each
    property is an alias and its value is the path the alias points to.
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          .aliases({
              '@': path.resolve(__dirname, 'assets/js/vue')
          })
          ```
        b: |
          ```javascript
          .addAliases({
              '@': path.resolve(__dirname, 'assets/js/vue')
          })
          ```
        c: |
          ```javascript
          .aliases: {
              '@': path.resolve(__dirname, 'assets/js/vue')
          }
          ```
        d: |
          ```javascript
          .addAliases: () => ({
              '@': path.resolve(__dirname, 'assets/js/vue')
          })
          ```
      correct: b

extending_vfor:
  question: |
    Suppose we have an imaginary component with the following data property:

    ```javascript
    data() {
        return {
            fruits: [
                'Banana',
                'Strawberry',
                'Pienapple',
                'Apple',
            ],
        };
    },
    ```

    Delicious! Now e want to loop through these fruits and show each of them in a `span`
    element. What's the best way to accomplish this?
  explanation: |
    That's correct! The `v-for` directive will produce copies of itself,
    each rendering one element in the array that you are looping through. The `:key`
    attribute helps Vue make better updates if the contents of `fruit` change!

    > Note you can also loop through Objects using this directive!
    > `v-for="(value, key, index) in object"` will do it!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <span
              v-for="fruit in fruits"
          >
              {{ fruit }}
          </span>
          ```
        b: |
          ```vue
          <div v-for="(fruit, index) in fruits">
              <span
                  :key="index"
              >
                  {{ fruit }}
              </span>
          </div>
          ```
        c: |
          ```vue
          <span
              v-for="(fruit, index) in fruits"
              :key="index"
          >
              {{ fruit }}
          </span>
          ```
        d: |
          ```vue
          <span>
              {{ fruits.reduce((fruit, acc) => { acc += 'fruit '; }, ''); }}
          </span>
          ```
      correct: c

extending_v-on:
  question: |
    Let's imagine we have these two boolean variables: `collapsed` and `darkMode`
    and we want to change the width and color of an element based on the
    state of these. What is the correct way to accomplish this using a `style`
    attribute?
  explanation: |
    Correct! the `:style` special attribute accepts an object where you can make
    each of its properties correspond to a style rule. Then have its value be
    the result of any JavaScript expression!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          :style="{
              width: collapsed ? '70px' : 'auto',
              color: darkMode ? 'white' : 'black',
              backgroundColor: darkMode ? 'black' : 'white',
          }"
          ```
        b: |
          ```vue
          :style="[
              { width: collapsed ? '70px' : 'auto' },
              { color: darkMode ? 'white' : 'black' },
              { backgroundColor: darkMode ? 'black' : 'white' },
          ]"
          ```
        c: |
          ```vue
          :style="`width: ${collapsed ? '70px' : 'auto'}; color: ${darkMode ? 'white' : 'black'}; backgroundColor: ${darkMode ? 'black' : 'white'}`"
          ```
        d: |
          ```vue
          style="{
              width: collapsed ? '70px' : 'auto',
              color: darkMode ? 'white' : 'black'
              backgroundColor: darkMode ? 'black' : 'white',
          }"
          ```
      correct: a

extending_v-on2:
  question: |
    Say we have a component with the data key `promoText` set to a string.
    Which one of these examples of a template will NOT render a single text node
    inside the `span` element?
  explanation: |
    That's right! A `v-text` directive present in an element will *ignore* any child
    elements you might add!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <span>{{ myText }}</span>
          ```
        b: |
          ```vue
          <span v-text="myText" />
          ```
        c: |
          ```vue
          <span v-text="myText">
              <h1>Some other stuff!</h1>
          </span>
          ```
        d: |
          ```vue
          <span>
              {{ myText }}
              <h1>Some other stuff!</h1>
          </span>
          ```
      correct: d

extending_v-on3:
  question: |
    Suppose we have a component where an element of its template looks like this:

    ```vue
    <button @click="onFormSubmit">Submit form!</button>
    ```

    How could we print `Form submit button clicked!` to the console each time
    this button is clicked?
  explanation: |
    That's right! On click, Vue will effectively call `this.onFormSubmit()`
    and adding a key inside your component's `methods` option is the way to
    add methods to your Vue instance.
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          export default {
              methods() {
                  const onFormSubmit = function() {
                      console.log('Form submit button clicked!');
                  };

                  return onFormSubmit;
              }
          };
          ```
        b: |
          ```javascript
          export default {
              methods: {
                  onFormSubmit() {
                      console.log('Form submit button clicked!');
                  },
              },
          };
          ```
        c: |
          ```javascript
          export default {
              computed: {
                  onFormSubmit() {
                      console.log('Form submit button clicked!');
                  },
              },
          };
          ```
        d: |
          ```javascript
          export default {
              onFormSubmit() {
                  console.log('Form submit button clicked!');
              },
          };
          ```
      correct: b

extending_reactivity:
  question: |
    Generally speaking, how does Vue go about making your `data` and `props` members
    reactive? In other words: how is Vue smart enough to re-render components
    when `data` or `props` change?
  explanation: |
    That's right! Vue turns your `data` and `prop` members into getter and setter functions.
    When those properties are complex objects, it even does this recursively!
    When you access a key in `data` or `props`, Vue uses the getter to keep an
    internal list of all components thta *use* that key. And when you *set*
    a key on `data`, Vue is then able to notify all components that use that key.
    *Then* those components can re-render.

    Pretty cool, eh?
  features:
    multiple_choice:
      choices:
        a: |
          By running a scheduled task periodically in order to check for changes in the
          data structure of `data` and `props`.
        b: |
          By running `setInterval()` with a function that constantly re-renders your component.
          Because of the virtual DOM, this re-rendering is very efficient.
        c: |
          By turning all of your members into functions.
        d: |
          By turning all of your members into getters and setters.
      correct: d

extending_instancedynamicdata:
  question: |
    Suppose we have a Vue component that looks like this:

    ```javascript
    const app = new Vue({
        el: '#app',
        template: '<span class="title">{{ title }}</span>
    });
    ```

    and you want to add `title` as a new "data" key to this component.
    How could we do that *and* set its initial value to `Vue challenge!`.
    How would you go about initializing this data?
  explanation: |
    That's right! `data` is a function that returns an object. The properties
    in this object will be accessible from the template! The function shorthand
    syntax - `data() {}` instead of `data: function() {}` - allows us to make our
    component more readable.
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          data: `title='Vue challenge!'`,
          ```
        b: |
          ```javascript
          data() { return { title: 'Vue challenge!' }; },
          ```
        c: |
          ```javascript
          data() { title = 'Vue challenge!'; },
          ```
        d: |
          ```javascript
          data: 'Vue challenge!',
          ```
      correct: b

extending_singlefilecomponent:
  question: |
    Imagine you want to build a `.vue` single file component that renders a
    page header. It needs to have a `title` data key that it uses to render the
    template.

    Which one of these code snippets would accomplish this?
  explanation: |
    Correct! A vue single file component has at least 2 elements: a `<template>`
    tag that holds the template and a `<script>` tag that `export default`
    one object with the rest of the options.
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <h1>{{ title }}</h1>

          <script>
          const component = {
              name: 'TitleComponent',
              data: {
                  title: '',
              },
          };
          </script>
          ```
        b: |
          ```vue
          <template>
              <h1>{{ title }}</h1>
          </template>

          <script>
          const name = 'TitleComponent';
          const data = {
              title: ''
          };
          </script>
          ```
        c: |
          ```vue
          <template>
              <h1>{{ title }}</h1>
          </template>

          <script>
          const name = 'TitleComponent';
          const data = function() {
              return {
                  title: ''
              };
          };
          </script>
          ```
        d: |
          ```vue
          <template>
              <h1>{{ title }}</h1>
          </template>

          <script>
          export default {
              name: 'TitleComponent',
              data() {
                  return { title: '' };
              },
          };
          </script>
          ```
      correct: d

extending_dataandvuedevtools:
  question: |
    Which of these is NOT a valid way to initialize a data object
    in Vue?
  explanation: |
    That's right! Data can be just an `Object`, or (more commonly) a function
    that *returns* an `Object`! Option "b" is proper syntax but doesn't return
    anything!
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          data: {
              legend: "My Legend Goes Here!",
          },
          ```
        b: |
          ```javascript
          data: function() {
              const legend = "My Legend Goes Here!;
          },
        c: |
          ```javascript
          data() {
              return {
                  legend: "My Legend Goes Here!",
              };
          },
          ```
        d: |
          ```javascript
          data: () => ({
              legend: "My Legend Goes Here!",
          }),
          ```
      correct: b

extending_childcomponent:
  question: |
    Which of these is NOT a reason to consider breaking a component
    into smaller sub-components?
  explanation: |
    Correct! Splitting a component into smaller components can help you reuse code,
    isolate complex logic, or make your templates smaller and more readable. But
    this has no (significant) effect on the final size of your JavaScript code.
  features:
    multiple_choice:
      choices:
        a: Part of the component has a special functionality/logic.
        b: Part of the component needs to be reused in other parts of the application.
        c: Extracting part of the component will make its footprint smaller.
        d: Extracting part of a template into a sub-component will make it easier to read and understand.
      correct: c

extending_childcomponent2:
  question: |
    Suppose we have an empty component that looks like this:

    ```vue
    <template>
        <div></div>
    </template>

    <script>
    export default {
        name: 'MainComponent',
    };
    </script>
    ```

    We now want to import a child component (that lives at `@/components/title-component`)
    and render it inside `MainComponent`. What code would accomplish this?
  explanation: |
    Correct! First, you need to import the file that holds the Vue component
    (like normal JavaScript). Next, the `components` option is an *object* containing
    all of the components that you want to make *available* in the template. Once
    you've made it available, you can *use* it in the template!

    Fun fact: the reason `components` is an object is that you are *really* setting
    a key-value pair of components to make available. For example:

    ```
    export default {
        // ...
        components: {
            // this is short for TitleComponent: TitleComponent
            TitleComponent,

            // you won't do this, but it's legal to set any key to a component
            // this would allow us to use <foo /> in the template to render the title
            foo: TitleComponent
        },
    };
    ```
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <div></div>
          </template>

          <script>
          import TitleComponent from '@/components/title-component';

          export default {
              name: 'MainComponent',
              components: {
                  TitleComponent,
              },
          };
          </script>
          ```
        b: |
          ```vue
          <template>
              <div><title-component /></div>
          </template>

          <script>
          import TitleComponent from '@/components/title-component';

          export default {
              name: 'MainComponent',
              components: {
                  TitleComponent,
              },
          };
          </script>
          ```
        c: |
          ```vue
          <template>
              <div><title-component /></div>
          </template>

          <script>
          import TitleComponent from '@/components/title-component';

          export default {
              name: 'MainComponent',
              components: [
                  TitleComponent,
              ],
          };
          </script>
          ```
        d: |
          ```vue
          <template>
              <div><title-component /></div>
          </template>

          <script>
          export default {
              name: 'MainComponent',
              components: {
                  TitleComponent,
              },
          };
          </script>
          ```
      correct: b

extnding_passinginfotochild:
  question: |
    Suppose we have a shiny Title component that looks like this:

    ```vue
    <template>
        <div>{{ title }}</div>
    </template>

    <script>
    export default {
        name: 'TitleComponent',
    };
    </script>
    ```

    We want other components to be able to pass a `title` to this component as a prop.
    Which option would NOT be a valid way to define the `title` prop?
  explanation: |
    Correct! To define `props` for our component, we need to declare the
    component's `props` property. Its simplest form is an array
    of strings, where each string is a prop name!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          export default {
              name: 'TitleComponent',
              props: ['title'],
          };
          ```
        b: |
          ```vue
          export default {
              name: 'TitleComponent',
              props: {
                  title: String,
              },
          };
          ```
        c: |
          ```vue
          export default {
              name: 'TitleComponent',
              props: {
                  title: {
                      type: String,
                  },
              },
          };
          ```
        d: |
          ```vue
          export default {
              name: 'TitleComponent',
              props: { 'title' : true },
          };
          ```
      correct: d

extnding_passinginfotochild2:
  question: |
    Ok! Say we have a TitleComponent that accepts a `title` prop.

    Imagine that we want to pass the string `Discount Broken Furniture` to it
    from a parent component. What's the correct way to do this in a template?
  explanation: |
    That's right! Props behave exactly like HTML attributes in Vue! The easiest
    way to pass down a prop is to just declare it staticaly as an attribute.
    In our next lesson, we explore the other way of passing a prop: Using the
    `v-bind` directive, which allows us to use JavaScript for dynamic prop values!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <title-component prop:title="Discount Broken Furniture" />
          </template>
          ```
        b: |
          ```vue
          <template>
              <title-component title="Discount Broken Furniture" />
          </template>
          ```
        c: |
          ```vue
          <template>
              <title-component title="'Discount Broken Furniture'" />
          </template>
          ```
        d: |
          ```vue
          <template>
              <title-component :title="Discount Broken Furniture" />
          </template>
          ```
      correct: b

extending_dynamicattributes:
  question: |
    Suppose we have a component named `TitleComponent` that is ready to be
    used. This component accepts a `title` prop and we want to populate it with
    the value of an imaginary data key called `categoryName`. Our main component
    looks like this:

    ```vue
    <template>
        <title-component />
    </template>

    <script>
    import TitleComponent from '@/components/title-component';

    export default {
        name: 'MainComponent',
        components: {
            TitleComponent
        },
        data() {
            return {
                categoryName: 'Broken Cups',
            }
        },
    };
    </script>
    ```

    How would you pass this value down to a property of `title-component`
    using the shortcut syntax?
  explanation: |
    Correct! When using the shortcut syntax - equivalent to `v-bind:title` - we're
    converting the attribute value into a JavaScript expression where we can
    access all our object's props and data members directly. So doing
    `:title="ourTitle"` will work just fine!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <title-component :title="categoryName" />
          </template>
          ```
        b: |
          ```vue
          <template>
              <title-component title="{{ categoryName }}" />
          </template>
          ```
        c: |
          ```vue
          <template>
              <title-component :title="{{ categoryName }}" />
          </template>
          ```
        d: |
          ```vue
          <template>
              <title-component :title="'categoryName'" />
          </template>
          ```
      correct: a

extending_dynamicattributes2:
  question: |
    Say we have a component with a prop `title` defined using the simple
    syntax:

    ```javascript
    props: ['title'],
    ```

    But now, we'd like Vue to be able to do some validation for us when
    the component is rendered: we want `title` to accept a String and to
    be required. How can we do this?
  explanation: |
    Correct! We *need* to pass an object whose members are equal to the names
    of our defined props. Each member is  itself another object with the
    options `type` - which can be equal to a JavaScript type object, like
    `String` - and `required`, which is a boolean.

    > When `required` is `false`, you can also define a `default` value using
    > that option.

    > Types are defined using JavaScript type classes, not its instantiated
    > objects. That's why `String` works but `String()`, `'String'`, `''`, or
    > `new String()` will fail!
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          props: {
              title: {
                  type: String,
                  required,
              },
          },
          ```
        b: |
          ```javascript
          props: {
              title: [String, true],
          },
          ```
        c: |
          ```javascript
          props: {
              title: {
                  type: String,
                  required: true,
              },
          },
          ```
        d: |
          ```javascript
          props: {
              title: {
                  type: new String(),
                  required: true,
              },
          },
          ```
      correct: c

extending_modularcss:
  question: |
    What is the *minimum* code you need in a `<style>` tag (inside a `.vue`
    single file component) to make it modular?
  explanation: |
    That's right, the only thing you need to add to it in order to make it
    modular is the `module` attribute! While a similar and valid option
    would be `scoped` attribute, this doesn't exactly compute into a "modular"
    style system using webpack.
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <style module>
          </style>
          ```
        b: |
          ```vue
          <style lang="scss" module>
          </style>
          ```
        c: |
          ```vue
          <style type="module">
          </style>
          ```
        d: |
          ```vue
          <style scoped>
          </style>
          ```
      correct: a

extending_modularcss2:
  question: |
    Imagine we have a component with the following modular css:

    ```vue
    <style module>
    .component {
        background-color: red;
    }
    </style>
    ```

    What do we need to do in the template to grab this style class from
    inside our component template?
  explanation: |
    You did it!

    In order to access modular css, we *need* to use the `$style` variable using a v-bind
    directive! Style is actually an object with a property for every class defined
    in `<style>`.

    Each property is mapped to whatever that class ends up being in the final
    code!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          class="$style.component"
          ```
        b: |
          ```vue
          :class="style.component"
          ```
        c: |
          ```vue
          class="style.component"
          ```
        d: |
          ```vue
          :class="$style.component"
          ```
      correct: d

extending_aliases:
  question: |
    Suppose you have this code:

    ```javascript
    import Legend from '@/components/legend';
    ```

    When you run the code, this successfully loads the
    `/assets/js/vue/components/legend.vue` file. How does this work?
  explanation: |
    Correct! We use `.addAliases()` in Webpack Encore to easily configure
    Webpack aliases for our project. In Vue, having the `@` alias set to the
    project's root directory is common practice!
  features:
    multiple_choice:
      choices:
        a: |
          Vue adds a shortcut where the `@` symbol resolves to the root directory
          where the top level component is created (e.g. `assets/js/vue`).
        b: |
          In Webpack, the `@` symbol gets you to the root of the "entry" file.
        c: |
          The project must have a Webpack Alias for `@` configured.
        d: |
          This project must have a Vue "directory root" set for the `@` symbol.
      correct: c

extending_vfor:
  question: |
    Suppose we have an imaginary component with the following data property:

    ```javascript
    data() {
        return {
            fruits: [
                'Banana',
                'Strawberry',
                'Pienapple',
                'Apple',
            ],
        };
    },
    ```

    Delicious! Now e want to loop through these fruits and show each of them in a `span`
    element. What's the best way to accomplish this?
  explanation: |
    That's correct! The `v-for` directive will produce copies of itself,
    each rendering one element in the array that you are looping through. The `:key`
    attribute helps Vue make better updates if the contents of `fruit` change!

    > Note you can also loop through Objects using this directive!
    > `v-for="(value, key) in object"` will do it!

    > If you are iterating through an Object and *still* need to get an index
    > number, you can use the syntax:
    > `v-for="(value, key, index) in object"`
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <span
              v-for="fruit in fruits"
          >
              {{ fruit }}
          </span>
          ```
        b: |
          ```vue
          <div v-for="(fruit, index) in fruits">
              <span
                  :key="index"
              >
                  {{ fruit }}
              </span>
          </div>
          ```
        c: |
          ```vue
          <span
              v-for="(fruit, index) in fruits"
              :key="index"
          >
              {{ fruit }}
          </span>
          ```
        d: |
          ```vue
          <span>
              {{ fruits.reduce((fruit, acc) => { acc += 'fruit '; }, ''); }}
          </span>
          ```
      correct: c

extending_v-on:
  question: |
    Let's imagine we have these two boolean variables: `collapsed` and `darkMode`
    and we want to change the width and color of an element based on the
    state of these. What is the correct way to accomplish this using a `style`
    attribute?
  explanation: |
    Correct! the `:style` special attribute accepts an object where you can make
    each of its properties correspond to a style rule. Then have its value be
    the result of any JavaScript expression!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          :style="{
              width: collapsed ? '70px' : 'auto',
              color: darkMode ? 'white' : 'black',
              backgroundColor: darkMode ? 'black' : 'white',
          }"
          ```
        b: |
          ```vue
          :style="[
              { width: collapsed ? '70px' : 'auto' },
              { color: darkMode ? 'white' : 'black' },
              { backgroundColor: darkMode ? 'black' : 'white' },
          ]"
          ```
        c: |
          ```vue
          :style="`width: ${collapsed ? '70px' : 'auto'}; color: ${darkMode ? 'white' : 'black'}; backgroundColor: ${darkMode ? 'black' : 'white'}`"
          ```
        d: |
          ```vue
          style="{
              width: collapsed ? '70px' : 'auto',
              color: darkMode ? 'white' : 'black'
              backgroundColor: darkMode ? 'black' : 'white',
          }"
          ```
      correct: a

extending_v-on2:
  question: |
    Suppose you have a `promoText` data set to `Office chairs now have 33% less wheels`.
    In a template, you have this:

    ```vue
    <span v-text="promoText">
      <span>... and more text</span>
    </span>
    ```

    What will this template print?
  explanation: |
    That's right! A `v-text` directive present in an element will *ignore* any child
    elements you might add!
  features:
    multiple_choice:
      choices:
        a: |
          ```html
          <span text="Office chairs now have 33% less wheels">
              <span>... and more text</span>
          </span>
          ```
        b: |
          ```html
          <span>
              Office chairs now have 33% less wheels
              <span>... and more text</span>
          </span>
          ```
        c: |
          ```html
          <span>
              <span>Office chairs now have 33% less wheels</span>
              <span>... and more text</span>
          </span>
          ```
        d: |
          ```html
          <span>
              Office chairs now have 33% less wheels
          </span>
          ```
      correct: d

extending_v-on3:
  question: |
    Suppose we have a component where an element of its template looks like this:

    ```vue
    <button @click="onFormSubmit">Submit form!</button>
    ```

    How could we print `Form submit button clicked!` to the console each time
    this button is clicked?
  explanation: |
    That's right! On click, Vue will effectively call `this.onFormSubmit()`
    and adding a key inside your component's `methods` option is the way to
    add methods to your Vue instance.
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          export default {
              methods() {
                  const onFormSubmit = function() {
                      console.log('Form submit button clicked!');
                  };

                  return onFormSubmit;
              }
          };
          ```
        b: |
          ```javascript
          export default {
              methods: {
                  onFormSubmit() {
                      console.log('Form submit button clicked!');
                  },
              },
          };
          ```
        c: |
          ```javascript
          export default {
              computed: {
                  onFormSubmit() {
                      console.log('Form submit button clicked!');
                  },
              },
          };
          ```
        d: |
          ```javascript
          export default {
              onFormSubmit() {
                  console.log('Form submit button clicked!');
              },
          };
          ```
      correct: b

extending_reactivity:
  question: |
    Generally speaking, how does Vue go about making your `data` and `props` members
    reactive? In other words: how is Vue smart enough to re-render components
    when `data` or `props` change?
  explanation: |
    That's right! Vue turns your `data` and `prop` members into getter and setter functions.
    When those properties are complex objects, it even does this recursively!
    When you access a key in `data` or `props`, Vue uses the getter to keep an
    internal list of all components that *use* that key. And when you *set*
    a key on `data`, Vue is then able to notify all components that use that key.
    *Then* those components can re-render.

    Pretty cool, eh?
  features:
    multiple_choice:
      choices:
        a: |
          By running a scheduled task periodically in order to check for changes in the
          data structure of `data` and `props`.
        b: |
          By running `setInterval()` with a function that constantly re-renders your component.
          Because of the virtual DOM, this re-rendering is very efficient.
        c: |
          By turning all of your members into functions.
        d: |
          By turning all of your members into getters and setters.
      correct: d

extending-v-show:
  question: |
    Pizza time! Check out the following component where we need to hide or show
    a "Loading" message depending on a `loading` state.

    ```vue
    <template>
        <span>Loading...</span>

        <h1>Pizza Menu</h1>

        <pizza-menu-list />
    </template>

    <script>
    import PizzaMenuList from '@/components/pizza-menu-list';

    export default {
        name: 'MainComponent',
        components: {
            PizzaMenuList
        },
        data() {
            return {
                loading: true,
            };
        },
    };
    </script>
    ```

    What is the best way to hide and show the "Loading" `<span>`?
  explanation: |
    Exactly! Vue has a directive ready for just these sort of cases! We don't need to
    do anything fancy. Just use the `v-show` directive (or the `v-if` if changes would
    be more permanent) and the rest is handled by Vue!

    > Notice that the `:style` option is doing pretty much exactly what our `v-show`
    > directive ends up doing in the DOM, but `v-show` is much cleaner!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <span>{{ loading ? 'Loading...' : '' }}</span>
          ```
        b: |
          ```vue
          <span :class="{ loading }">Loading...</span>
          ```
        c: |
          ```vue
          <span v-show="loading">Loading...</span>
          ```
        d: |
          ```vue
          <span :style="{ display: loading ? '' : 'none' }">Loading...</span>
          ```
      correct: c

extending-v-show-2:
  question: |
    What is the difference between the `v-show` and `v-if` directives?
  explanation: |
    Correct! While `v-show` will leave the elements in the DOM for a quick hide/show
    operation, `v-if` will completely render or remove the elements depending on
    its state.

    It *is* true that, if a complex section may not be displayed at *all* on initial
    load, using `v-if` is more performant because Vue spend *any* time rendering
    what's inside.
  features:
    multiple_choice:
      choices:
        a: |
          `v-show` uses a style rule to show or hide the Element in question, while
          `v-if` removes or appends the Element in the DOM.
        b: |
          `v-show` is used for faster render times, while `v-if` uses less resources.
        c: |
          `v-show` is used for showing or hiding elements in the dom, while `v-if`
          is used for control flow operations, much like in Twig.
        d: |
          They are two different ways to do the same thing
      correct: a

extending-v-show-3:
  question: |
    Let's say we have a class called `.controversial-flavor` in a modular css tag. We want
    to assign this class to an element in the template if our pizza cointains pineapple. For this,
    we've constructed a component like this:

    ```vue
    <template>
        <div :class="$style.component">
          <span>{{ pizza.name }}</span>
        </div>
    </template>

    <script>
    export default {
        name: 'PizzaName',
        props: ['pizza'],
    };
    </script>

    <style lang="scss" module>
    .component {
        width: 120px;
        display: inline-block

        .controversial-flavor {
            color: red;
        }
    }
    </style>
    ```

    We know that `pizza` has a property called `containsPineapple`, which is a boolean.
    How can we conditionally show the `.controversial-flavor` class if the pizza contains
    pineapple?
  explanation: |
    That's right! We're faced with the problem of, first, referencing a class whose name
    has a `-` in it, so we have to use `[]` around the `$style` variable:

    ```javascript
    $style['controversial-flavor']
    ```

    But that's not all! In order to include this property as an object *key*, we *again* need
    to enclose this in another pair of `[]`. The result is as the one you selected.
    It's ugly, but correct:

    ```javascript
    { [$style['controversial-flavor']] : pizza.containsPineapple }
    ```
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <span :class="{
              $style['controversial-flavor']: pizza.containsPineapple
          }">
              {{ pizza.name }}
          </span>
          ```
        b: |
          ```vue
          <span :class="{
              [$style['controversial-flavor']]: pizza.containsPineapple
          }">
              {{ pizza.name }}
          </span>
          ```
        c: |
          ```vue
          <span :class="{
              'controversial-flavor': pizza.containsPineapple
          }">
              {{ pizza.name }}
          </span>
          ```
        d: |
          ```vue
          <span :class="[
              'controversial-flavor', pizza.containsPineapple
          ]">
              {{ pizza.name }}
          </span>
          ```
      correct: b

extending_computed:
  question: |
    Let's say we have a component that contains two data properties: `firstName` and
    `lastName`. To make our lives easier, we want to display these names using a single
    `name` variable in the template:

    ```vue
    <template>
        <span :class="$style.component">{{ name }}</span>
    </template>
    ```

    What code would accomplish this in the best way?
  explanation: |
    That's right! `computed` is special for these type of issues. You would be able to access
    the computed property as if it were a reactive property *anywhere* in your component!

    For example, to access this computed property from a method, you can do:

    ```javascript
    this.name;
    ```

    That easy!

    > Make sure your computed property *returns* the end result as a value. Do not make the mistake
    > of assigning the end result to `this.name`, which is technically legal, becuase this would
    > cause and *endless* cascade of function calls, effectively hanging the browser until the
    > call stack limit is reached!
  features:
      multiple_choice:
        choices:
          a: |
            ```vue
            <script>
            export default {
                name: 'PersonComponent',
                data() {
                    return {
                        firstName: 'Ryan',
                        lastName: 'Weaver',
                        name: '',
                    },
                },
                mounted() {
                    this.name = this.firstName + ' ' + this.lastName;
                },
            };
            </script>
            ```
          b: |
            ```vue
            <script>
            export default {
                name: 'PersonComponent',
                data() {
                    return {
                        firstName: 'Ryan',
                        lastName: 'Weaver',
                    },
                },
                computed {
                    name() {
                        const name = this.firstName + ' ' + this.lastName;
                    },
                },
            };
            </script>
            ```
          c: |
            ```vue
            <script>
            export default {
                name: 'PersonComponent',
                data() {
                    return {
                        firstName: 'Ryan',
                        lastName: 'Weaver',
                    },
                },
                computed {
                    name() {
                        this.name = this.firstName + ' ' + this.lastName;
                    },
                },
            };
            </script>
            ```
          d: |
            ```vue
            <script>
            export default {
                name: 'PersonComponent',
                data() {
                    return {
                        firstName: 'Ryan',
                        lastName: 'Weaver',
                    },
                },
                computed {
                    name() {
                        return (this.firstName + ' ' + this.lastName);
                    },
                },
            };
            </script>
            ```
        correct: d

extending_whereshoulddatalive:
  question: |
    Let's say you have a component with a prop named `firstName` and you change it inside
    that component using a method like so:

    ```vue
    <template>
        <span>{{ name }}</span>
        <button @click="changeFirstName">Change First Name</button>
    </template>

    <script>
    export default {
        name: 'NameComponent',
        props: ['firstName', 'lastName'],
        computed: {
            name() {
                return this.firstName + ' ' + this.lastName;
            }
        },
        methods: {
            changeFirstName() {
                this.firstName = 'Beckett';
            },
        },
    };
    </script>
    ```

    What is wrong with this code?
  explanation: |
    That's right. While it is possible to mutate a prop, you should *never* do that!
    The appication will throw a warning and it will still work. But if `firstName`
    is stored as data in a parent component, it will now be out-of-sync with the
    `firstName` prop in this component! Worse, if the data changes in the parent
    component, it will *override* our mutated value.

    So, even though you "can", NEVER mutate a prop!
  features:
    multiple_choice:
      choices:
        a: |
          When you mutate a prop, you need to also emit an event so that the parent
          component is aware.
        b: |
          You shouldn't mutate a prop.
        c: |
          The `changeFirstName()` method must have an `event` argument.
        d: |
          `firstName` should be moved to `data`. Then, we should set its initial value to
          the `firstName` prop.
      correct: b

extending_emit:
  question: |
    Which of these examples will NOT emit an event called `button_click` when the button
    is clicked?
  explanation: |
    If you look closely, `:click` will not be executed because you are actually
    defining a dynamic attribute called `click` set to the `$emit` call. Well done!

    > You can call `$emit` from the template, or from methods in your
    > component.
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <button :click="$emit('button_click')" />
          </template>

          <script>
          export default {
              name: 'ButtonComponent',
          };
          </script>
          ```
        b: |
          ```vue
          <template>
              <button @click="$emit('button_click')" />
          </template>

          <script>
          export default {
              name: 'ButtonComponent',
          };
          </script>
          ```
        c: |
          ```vue
          <template>
              <button @click="onButtonClicked" />
          </template>

          <script>
          export default {
              name: 'ButtonComponent',
              methods: {
                  onButtonClicked() {
                      this.$emit('button_click');
                  },
              },
          };
          </script>
          ```
        d: |
          ```vue
          <template>
              <button v-on:click="onButtonClicked" />
          </template>

          <script>
          export default {
              name: 'ButtonComponent',
              methods: {
                  onButtonClicked() {
                      this.$emit('button_click');
                  },
              },
          };
          </script>
          ```
      correct: a

extending_ajaxwithaxios:
  question: |
    What is the purpose of the special `mounted()` function in Vue?
  explanation: |
    That's right. It's a special event callback that you can define in your
    components to do stuff *just after* a component is mounted in the DOM.

    This is very useful to perform stuff that needs DOM elements to be present.
    While this is not common in Vue, you might still need to get a reference
    to an Element directly.
  features:
    multiple_choice:
      choices:
        a: |
          It's purpose is to mount other components in the DOM when called
        b: |
          It's purpose is to execute code that results in DOM elements that will
          be mounted in the DOM
        c: |
          It's purpose is to execute code right after the component has been
          mounted in the DOM
        d: |
          It's purpose is to execute code on component initialization
      correct: c

extending_smartvsdumbcomponents:
  question: |
    In the world of Vue and React, what is the relationship between "Dumb" and
    "Smart" components?
  explanation: |
    Correct! Smart components are the logic bearing components, usually getting
    data from the server and preparing it in different ways, while dumb components
    only "present" that data to the user.

    This creates a pattern that's similar to controllers and templates in Symfony.
    A controller (smart component) contains logic and passes variables into a
    template (dumb component) that mostly just renders those.

    If you keep this idea in mind, it can help you keep your components more
    organized.
  features:
    multiple_choice:
      choices:
        a: |
          A smart component usually makes smart computations, while a dumb component
          does the more common tasks.
        b: |
          A smart component usually is in charge of doing the logic of the application,
          while a dumb component usually gets that data and renders it in a template.
        c: |
          A smart compponent usually is at the top of a component tree, while a dumb
          component is more at the bottom.
        d: |
          A smart component usually does AI related things, like image processing, while
          a dumb component handles the rest of the application logic.
      correct: b

extending_loadingcomponent:
  question: |
    In Vue, when should we use `created` instead of `mounted` for our components?
  explanation: |
    That's right! `created` will execute as soon as the component is instantiated. Even
    though the DOM structure still *isn't* mounted, you can still perform any other
    operations that deal with reactive data!

    `mounted`, on the other hand, will be executed once the component has been mounted
    in the DOM. This is useful for any edge case when you need to manipulate the
    DOM directly!
  features:
    multiple_choice:
      choices:
        a: |
          `created` should be used when you need to perform an action as soon as
          the component has been instantiated but you don't need access to the DOM
          directly.
        b: |
          `created` should be used only when you need to perform synchronous operations
          when the component is instantiated.
        c: |
          `created` should be used only when you need to perform asynchronous operations
          when the component is instantiated.
        d: |
          `created` is an internal function and should not be used directly.
      correct: a

extending_data_global_classes:
  question: |
    Suppose we have a global piece of data that we need to render in our template. This
    data is `window.randomTurtleFact` and contains a special fact about turtles that we randomly
    get from the server each time a template loads. Sweet! Sea turtles can't retract
    their heads and flippers!

    Which of these examples would *fail* to render that global variable in the template?
  explanation: |
    That is correct! While `data` and `computed` are probably the best two options here
    there's nothing really wrong with getting it from a method.

    > Remember that referencing global variables in the template isn't possible because
    > everything there is bound to the magic `this` object. So, `window.randomTurtleFact`
    > effectively means `this.window.randomTurtleFact`.
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <h1>I love turtles</h1>

              <p>{{ window.randomTurtleFact }}</p>
          </template>

          <script>
          export default {
              name: 'MainComponent',
          };
          </script>
          ```
        b: |
          ```vue
          <template>
              <h1>I love turtles</h1>

              <p>{{ randomTurtleFact }}</p>
          </template>

          <script>
          export default {
              name: 'MainComponent',
              data() {
                  return {
                      randomTurtleFact: window.randomTurtleFact,
                  };
              },
          };
          </script>
          ```
        c: |
          ```vue
          <template>
              <h1>I love turtles</h1>

              <p>{{ randomTurtleFact }}</p>
          </template>

          <script>
          export default {
              name: 'MainComponent',
              computed: {
                  randomTurtleFact() {
                      return window.randomTurtleFact;
                  },
              },
          };
          </script>
          ```
        d: |
          ```vue
          <template>
              <h1>I love turtles</h1>

              <p>{{ getRandomTurtleFact() }}</p>
          </template>

          <script>
          export default {
              name: 'MainComponent',
              methods: {
                  getRandomTurtleFact() {
                      return window.randomTurtleFact;
                  },
              },
          };
          </script>
          ```
      correct: a

extending_page_context_service:
  question: |
    Suppose we have an application that needs to fetch a random fact about turtles and
    we implement a service to do this for us.

    Ignoring the fact that 3 of these use AJAX and 1 reads from a global variable
    (a service could do either), which one of the options is *not* a valid service?
  explanation: |
    That's correct! A service should do work for us and return something that we can use
    right away (even if that's just a promise!).
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          export default function getRandomTurtleFact() {
              return window.randomTurtleFact;
          }
          ```
        b: |
          ```javascript
          import axios from 'axios';

          export const randomTurtleFact = '';

          export function async getRandomTurtleFact() {
              const response = await axios.get('/api/random-fact');

              randomTurtleFact = response.data.message;
          }
          ```
        c: |
          ```javascript
          import axios from 'axios';

          export default function getRandomTurtleFact() {
              return axios.get('/api/turtles/random-fact');
          }
          ```
        d: |
          ```javascript
          import axios from 'axios';

          const myTurtleService = {
              async function getRandomTurtleFact() {
                  const response = await axios.get('/api/turtles/fact');

                  return response.data.message;
              },
          };

          export default myTurtleService;
          ```
      correct: b

extending_smarter_loading:
  question: |
    In this section, we learned that you can wrap any AJAX call in a `try...catch`
    to catch any errors that may arise during that AJAX call. We also say that we
    should limit that `try...catch` to *just* the statement that performs the call.

    Here's an example:

    ```vue
    async created() {
        this.loading = true;
        let response;

        try {
            response = await axios.get('/api/get-turtle');
        } catch(e) {
            this.loading = false;
            return;
        }

        this.loading = false;
        this.products = response.data;
    },
    ```

    Why is it important that the `try...catch` *only* includes the AJAX call?
  explanation: |
    That's right! To avoid having unexposed bugs in the code, we should limit
    `try...catch` in general to *only* the code that we know *can* fail under
    normal, expected circumstances - like if the user has a connection error
    or the server returns a 400 error if validation fails (if the AJAX call
    is sending data).

    Putting any code in a try catch that should *never* fail - like
    `this.products = response.data` - could accidentally hide the error for an
    edge-case that we hadn't thought about.
  features:
    multiple_choice:
      choices:
        a: |
          Because the other parts of our code are very straightforward
          and can never break - having them in the try-catch isn't necessary.
        b: |
          Because `try...catch` takes a lot of resources in the browser, so
          we should use it only when absolutely necessary.
        c: |
          Because if we expand the `try...catch` to other lines of code, we might
          be hiding a real bug in our application.
        d: |
          Because we should only handle possible bugs related to our API and not our
          application.
      correct: c

extending_skipping_ajax:
  question: |
    Too much loading in an app can be really bad! For that reason,
    we've decide to avoid AJAX calls for some parts of it.

    In our app, we pass the current category and the list of categories directly
    from the server, but *not* the list of *products*. Then, once the app
    bootstraps, we *must* make an AJAX call for the products.

    In theory... we could just dump everything in our template and have the
    page load instantly... So... why don't we do that?
  explanation: |
    This is a tricky one! And it depends on your app!

    First, even though the products are highly dynamic (they change much more often
    than the categories), we could still pass them directly from the server.
    However, if you used HTTP caching for your HTML response, you *would* need to
    invalidate that cache more often. But other than this edge-case, it's no problem!

    There *is* a tradeoff between loading more data in your controller versus
    making an AJAX call. Loading the products data in your controller *would* slow
    down how fast your server responds. But then, the data would be there instantly!
    The right answer depends on (A) how important the data is to the page (the less
    important, the more it makes sense to lazily load via an AJAX call) and (B)
    how heavy the data is (the heavier, the more it makes sense to delay loading
    to an AJAX call so that *some* part of the page can render quickly).

    Overall, remember to not optimize too early - you can always improve later!
  features:
    multiple_choice:
      choices:
        a: |
          Because if we did that, our HTML source would be too large and
          hard to read.
        b: |
          We could do that, but it would mean that our controller code needs
          to load more data. And so, the whole page would take longer to return
          from the server.
        c: |
          Because our products data come from an external source, so we
          have no choice but to load them using an external API.
        d: |
          Because our products are a highly volatile piece of data, meaning,
          they change all the time, so it's better to load them via AJAX.
      correct: b

extending_skipping_ajax2:
  question: |
    Which of these examples would be a good candidate to fetch via an
    AJAX call instead of passing the data directly from the server?
  explanation: |
    Another tricky one! And it ultimately depends on your app. Because the
    promotions information is probably *not* a critical component of the page
    *and* because it requires some heavy data calculation, it might be better
    to load that information via AJAX so that the initial page load is faster.

    All the other information - including the authenticated user information - is
    probably needed to render important parts of the page. Having this
    data immediately will give a better user experience.
  features:
    multiple_choice:
      choices:
        a: |
          The currently-authenticated user information / whether the user is logged
          in or not.
        b: |
          The currently available promotions that we offer on our website,
          which requires a heavy data calculation to determine.
        c: |
          Stuff that goes in our sidebar, like the list of categories.
        d: |
          The current category id or name.
      correct: b

extending_passing_props_vs_fetching:
  question: |
    Which of these cases is NOT a valid reason to skip the use of props for
    passing down data that is reactive?
  explanation: |
    That's right! Even if data is available through a service, if we later want
    to *change* that data and have its changes propagate properly throughout our
    application, we *need* to pass it down as props to other components that depend
    on it! With Vuex or Vue 3, there *are* other options.
  features:
    multiple_choice:
      choices:
        a: |
          My application uses Vuex, so its data is available from every component
          and is reactive.
        b: |
          In Vue 3, I have reactive data as outside modules that I can import
          from anywhere.
        c: |
          The data I'm passing down in props is available as a service.
        d: |
          The data will never change, and it's globally available, so it doesn't have
          to be reactive.
      correct: c

extending_v_model:
  question: |
    I just created my own `input` element with a `v-model` directive in it!
    Woo!

    ```vue
    <input
        type="text"
        placeholder="Enter your name..."
        v-model="firstName"
    />
    ```

    What is `v-model` NOT responsible for in this case?
  explanation: |
    That's right! As we've just seen, `v-model` is responsible for setting the
    `value` property of the element to `firstName` and *also* wiring the `@input`
    event so that changes to the input *set* the `firstName` data.

    This is effectibly a double-binding of our `firstName` data into the HTML
    component.

    But `v-model` does *not* also create the `firstName` key in `data`. That's
    our job!
  features:
    multiple_choice:
      choices:
        a: |
          It creates a `firstName` data property for us to use in the rest of our
          component.
        b: |
          It sets my element's `:value` property to `firstName`, which lives
          in my `data`.
        c: |
          It will set my data property `firstName` to the contents of the input
          whenever the user changes it, using `@input`.
        d: |
          It binds my data property `firstName` to our `input` element.
      correct: a

extending_filtering_products:
  question: |
    I LOVE hamsters. In fact, I love them so much that I wrote a Vue application
    that keeps track of all the hamsters I own. It's... a lot.

    One of the key parts of the app is the Hamster Counter component, which
    has to keep track of the total number of hamsters I own and print it on the screen.
    But, I'm having trouble wiring the custom events that I created!

    ```vue
    <template>
        <div>
            <h1>Hamster List</h1>
            <hamster-manager @on-hamster-list-update="updateCounter" />
        </div>
        <div>
            <hamster-counter :total-hamsters="totalHamsters" />
        </div>
    </template>
    ```

    What would the `script` section of this component look like in order to make
    this work (and be the best solution)?
  explanation: |
    Excellent job! That solution will keep the length as a `data` property in
    my main component that will automatically update my counter's `totalHamsters`
    prop!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <script>
          export default {
              name: 'MainComponent',
              computed: {
                  totalHamsters() {
                      return 0;
                  }
              },
              methods: {
                  updateCounter(data) {
                      this.totalHamsters = data.length;
                  },
              },
          };
          </script>
          ```
        b: |
          ```vue
          <script>
          export default {
              name: 'MainComponent',
              data() {
                  return {
                      hamstersLength: 0,
                  };
              },
              computed: {
                  totalHamsters() {
                      return hamstersLength;
                  }
              }
              methods: {
                  updateCounter(data) {
                      this.hamstersLength = data.length;
                  },
              },
          };
          </script>
          ```
        c: |
          ```vue
          <script>
          export default {
              name: 'MainComponent',
              props: {
                  totalHamsters: {
                      type: Number,
                      default: 0,
                  },
              },
              methods: {
                  updateCounter(data) {
                      this.totalHamsters = data.length;
                  },
              },
          };
          </script>
          ```
        d: |
          ```vue
          <script>
          export default {
              name: 'MainComponent',
              data() {
                  return {
                      totalHamsters: 0,
                  };
              },
              methods: {
                  updateCounter(data) {
                      this.totalHamsters = data.length;
                  },
              },
          };
          </script>
          ```
      correct: d

extending_async_computed:
  question: |
    Why can't computed properties be asynchronous?
  explanation: |
    That's right! A computed property function is executed whenever any of the reactive
    properties used inside it changes. This happens in the context of a re-render, meaning
    that the value that the computed property returns needs to be used *immediately*
    to render the template

    If a computed property returns a Promise... then a *Promise* (not the actual
    value you want) will be rendered in the template or passed down to child
    components as a prop. That's not what we want!

    > The concept of `reactivity` involves *No Promises*! Whenever a value change,
    > the template "reacts" at once!
  features:
    multiple_choice:
      choices:
        a: |
          Because it hasn't been implemented by Vue, but will be in Vue 3.
        b: |
          Because if you return a `Promise`... Vue will try to print a `Promise`
          in the template.
        c: |
          They can! But it's considered a bad practice.
        d: |
          Because the `async` keyword results in a syntax error in that context.
      correct: b

extending_business_helpers:
  question: |
    Helpers are useful aids to our app! But what are
    helpers NOT useful for as we're using them in this app?
  explanation: |
    Correct! If a so called *helper* is making API calls or preparing a piece of
    data from outside of our application to be used inside, we usually call them
    `services`.

    These terms - helpers & services - aren't universal definitions that are
    always used in this way. The important thing is that it's nice to separate
    your "pure functions that process logic and return something" (i.e. helpers)
    from "functions that manage data" (i.e. services).
  features:
    multiple_choice:
      choices:
        a: |
          Helpers are useful for separating a piece of code that we want to
          re-use elsewhere.
        b: |
          Helpers are useful for extracting a piece of our app logic that
          we want to unit-test.
        c: |
          Helpers are useful for extracting API calls and managing data
          processing needs in our application.
        d: |
          Helpers are useful for extracting part of our logic out of a component so
          that the component is easier to read and maintian.
      correct: c

extending_business_helpers2:
  question: |
    So I just set up this awesome helper that "helps" me put pineapple on top of
    regular pizzas! Yum! Here it is:

    ```javascript
    export default (pizzaTopping) => (
        pizzaTopping + ' with Pineapple!'
    );
    ```

    Now I want to use it in my pizza component so that every pizza topping has
    pineapple on it! Which of these examples would *not* make it work?
  explanation: |
    Exactly! Just like in our video, one of the simplest ways to use a helper
    to process some data that we want to output into our template is to have a
    computed property do the work.

    But you can also use other options, like wrapping the helper inside a method,
    or having it initialize inside your data function. But be careful with this
    last option - in this example, there isn't a good reason to "duplicate" the
    toppings by adding a new `data` variable.
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <h1>{{ pizza.name }}</h1>

              <h2>Topping:</h2>

              <p>{{ pizzaTopping }}</p>
          </template>

          <script>
          import getPizzaWithPineapple from '@/helpers/get-pizza-with-pineapple';

          export default {
              name: 'PizzaComponent',
              props: ['pizza'],
              computed: {
                  pizzaTopping() {
                      return getPizzaWithPineapple(pizza.topping);
                  },
              },
          };
          </script>
          ```
        b: |
          ```vue
          <template>
              <h1>{{ pizza.name }}</h1>

              <h2>Topping:</h2>

              <p>{{ getPizzaWithPineapple(pizza.topping) }}</p>
          </template>

          <script>
          import getPizzaWithPineapple from '@/helpers/get-pizza-with-pineapple';

          export default {
              name: 'PizzaComponent',
              props: ['pizza'],
          };
          </script>
          ```
        c: |
          ```vue
          <template>
              <h1>{{ pizza.name }}</h1>

              <h2>Topping:</h2>

              <p>{{ getPizzaTopping() }}</p>
          </template>

          <script>
          import getPizzaWithPineapple from '@/helpers/get-pizza-with-pineapple';

          export default {
              name: 'PizzaComponent',
              props: ['pizza'],
              methods: {
                  getPizzaTopping() {
                      return getPizzaWithPineapple(pizza.topping);
                  }
              },
          };
          </script>
          ```
        d: |
          ```vue
          <template>
              <h1>{{ pizza.name }}</h1>

              <h2>Topping:</h2>

              <p>{{ pizzaTopping }}</p>
          </template>

          <script>
          import getPizzaWithPineapple from '@/helpers/get-pizza-with-pineapple';

          export default {
              name: 'PizzaComponent',
              props: ['pizza'],
              data() {
                  return {
                      pizzaTopping: getPizzaWithPineapple(pizza.topping)
                  };
              },
          };
          </script>
          ```
      correct: b

extending_watchers:
  question: |
    It is said that `watchers` are our last resort in Vue: we should use them
    when no alternative method is present.

    More specifically, when should watchers be used in Vue?
  explanation: |
    That's right! If you need to perform an asynchronous operation as a result
    of a data or prop change, computed properties won't work for you!

    Ideally, there will be some event being emitted that you can respond to - e.g.
    "on click" of a button, you would trigger an AJAX call that would change some
    data. But if you don't have that option, use watchers!

    > Watchers are also useful to detect changes in `props`, where no other clear
    > option exists.
  features:
    multiple_choice:
      choices:
        a: |
          If we need to perform an asynchronous operation when the component
          loads, we should use watchers.
        b: |
          If we need to *frequently* listen to changes to data keys, a
          watcher is better.
        c: |
          If we need to listen to a prop change, or we need to perform an
          asynchronous operation as a result of some data change, we should
          use watchers.
        d: |
          We should never use watchers. They are deprecated!
      correct: c

extending_watchers2:
  question: |
    In my CarTitle component, I receive a `car` prop that contains both `model` and
    `brand` as separate keys. These two keys change when a user selects different
    options from 2 `select` elements that exist elsewhere on the page.

    What I'd like to do is "listen" to these prop change and automatically update
    the car title in the template.

    Which of these examples would do the job in the best way?
  explanation: |
    Perfect! Since our operation is totally synchronous for now, we really do NOT
    need to implement a watcher here. A computed property would work just fine!

    > Remember, watchers are to be used when no other good method is available to us!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <h1>{{ carName }}</h1>
          </template>

          <script>
          export default {
              name: 'CarTitle',
              props: ['car'],
              computed: {
                  carName() {
                      return car.brand + ' ' + car.model;
                  },
              },
          };
          </script>
          ```
        b: |
          ```vue
          <template>
              <h1>{{ carName }}</h1>
          </template>

          <script>
          export default {
              name: 'CarTitle',
              props: ['car'],
              data() {
                  return {
                      carName: car.brand + ' ' + car.model,
                  };
              },
              watchers: {
                  car(newVal) {
                      this.carName = newVal.brand + ' ' + newVal.model;
                  },
              },
          };
          </script>
          ```
        c: |
          ```vue
          <template>
              <h1>{{ carName }}</h1>
          </template>

          <script>
          export default {
              name: 'CarTitle',
              props: ['car'],
              data() {
                  return {
                      carName: this.getCarName(),
                  };
              },
              methods: {
                  getCarName() {
                      return car.brand + ' ' + car.model;
                  },
              },
          };
          </script>
          ```
        d: |
          ```vue
          <template>
              <h1>{{ getCarName }}</h1>
          </template>

          <script>
          export default {
              name: 'CarTitle',
              props: ['car'],
              methods: {
                  getCarName() {
                      return car.brand + ' ' + car.model;
                  },
              },
          };
          </script>
          ```
      correct: a
